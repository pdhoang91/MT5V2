//+------------------------------------------------------------------+
//|                                                 TradingBot.mq5    |
//|                        Generated by ChatGPT                       |
//+------------------------------------------------------------------+
#property strict

#include <ChartObjects\ChartObjectsTxtControls.mqh> // Thư viện để tạo đối tượng văn bản

//--- Input Parameters
// General Parameters
input int AnalysisPeriod = 7; // Number of days for historical analysis
input ENUM_TIMEFRAMES Timeframe = PERIOD_H1; // Trading timeframe
// Removed AssetClasses array to avoid input array issues
input string RiskManagementMode = "FixedLot"; // "FixedLot" or "Risk-Based"
input double FixedLotSize = 0.1; // Fixed lot size
input double RiskPercentage = 2.0; // Risk percentage per trade

// Performance Evaluation Parameters
input double MaxDrawdownWeight = 0.5;
input double WinRateWeight = 0.3;
input double AvgProfitWeight = 0.2;
// Removed ComparisonCriteria array to avoid input array issues

// Strategy-Specific Parameters
// Scalping
input int ScalpingBollingerBandsPeriod = 20;
input double ScalpingATRMultiplier = 1.5;
input double ScalpingSL_ATR_Multiplier = 1.0; // SL dựa trên ATR
input double ScalpingTP_ATR_Multiplier = 2.0; // TP dựa trên ATR

// Swing Trading
input int RSIPeriod = 14;
input int FastMAPeriod = 9;
input int SlowMAPeriod = 21;
input double SwingSL_ATR_Multiplier = 1.5; // SL dựa trên ATR
input double SwingTP_ATR_Multiplier = 3.0; // TP dựa trên ATR

// Breakout
input ENUM_TIMEFRAMES PivotPointPeriodTF = PERIOD_D1; // Pivot Points calculated daily
input double VolumeThreshold = 1.5;
input double BreakoutSL_ATR_Multiplier = 1.0; // SL dựa trên ATR
input double BreakoutTP_ATR_Multiplier = 2.0; // TP dựa trên ATR

// Mean Reversion
input double MeanReversionBollingerBandsDeviation = 2.0;
input double MeanReversionSL_ATR_Multiplier = 1.0; // SL dựa trên ATR
input double MeanReversionTP_ATR_Multiplier = 2.0; // TP dựa trên ATR

//--- Global Variables
datetime last_analysis_time = 0;

// Magic Number for Orders
#define MAGIC_NUMBER 123456

// Strategy enumeration
enum ENUM_STRATEGY {
    STRATEGY_SCALPING = 0,
    STRATEGY_SWING = 1,
    STRATEGY_BREAKOUT = 2,
    STRATEGY_MEANREV = 3
};

// Function to get magic number for a strategy
ulong GetStrategyMagicNumber(ENUM_STRATEGY strategy)
{
    switch(strategy) {
        case STRATEGY_SCALPING: return MAGIC_NUMBER + 1;
        case STRATEGY_SWING: return MAGIC_NUMBER + 2;
        case STRATEGY_BREAKOUT: return MAGIC_NUMBER + 3;
        case STRATEGY_MEANREV: return MAGIC_NUMBER + 4;
        default: return MAGIC_NUMBER;
    }
}

// Function to get strategy name
string GetStrategyName(ENUM_STRATEGY strategy)
{
    switch(strategy) {
        case STRATEGY_SCALPING: return "Scalping";
        case STRATEGY_SWING: return "Swing";
        case STRATEGY_BREAKOUT: return "Breakout";
        case STRATEGY_MEANREV: return "MeanRev";
        default: return "Unknown";
    }
}

//--- Dashboard Variables
double current_atr = 0.0;
double current_sl = 0.0;
double current_tp = 0.0;
double scalping_score = 0.0;
double swing_score = 0.0;
double breakout_score = 0.0;
double mean_reversion_score = 0.0;

// Performance Tracking Variables
struct StrategyPerformance {
    string strategy_name;
    int total_trades;
    int winning_trades;
    double total_profit;
    double max_drawdown;
    double current_drawdown;
    double win_rate;
    double avg_profit;
    double profit_factor;
    int open_positions;
};

StrategyPerformance strategy_stats[4]; // For 4 strategies

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
    // Khởi tạo dashboard
    CreateDashboard();
    InitializePerformanceTracking();
    return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Initialize Performance Tracking                                  |
//+------------------------------------------------------------------+
void InitializePerformanceTracking()
{
    string strategy_names[] = {"Scalping", "Swing", "Breakout", "MeanRev"};
    
    for(int i = 0; i < 4; i++) {
        strategy_stats[i].strategy_name = strategy_names[i];
        strategy_stats[i].total_trades = 0;
        strategy_stats[i].winning_trades = 0;
        strategy_stats[i].total_profit = 0.0;
        strategy_stats[i].max_drawdown = 0.0;
        strategy_stats[i].current_drawdown = 0.0;
        strategy_stats[i].win_rate = 0.0;
        strategy_stats[i].avg_profit = 0.0;
        strategy_stats[i].profit_factor = 0.0;
        strategy_stats[i].open_positions = 0;
    }
    
    LoadHistoricalPerformance();
}

//+------------------------------------------------------------------+
//| Load Historical Performance Data                                |
//+------------------------------------------------------------------+
void LoadHistoricalPerformance()
{
    datetime start_time = TimeCurrent() - (AnalysisPeriod * 24 * 60 * 60);
    
    for(int i = 0; i < 4; i++) {
        CalculateStrategyPerformance(strategy_stats[i], start_time);
    }
}

//+------------------------------------------------------------------+
//| Calculate Strategy Performance                                   |
//+------------------------------------------------------------------+
void CalculateStrategyPerformance(StrategyPerformance &stats, datetime start_time)
{
    double total_profit = 0.0;
    double total_loss = 0.0;
    int winning_trades = 0;
    int total_trades = 0;
    
    HistorySelect(start_time, TimeCurrent());
    int deals = HistoryDealsTotal();
    
    // Get strategy magic number
    ENUM_STRATEGY strategy_enum = GetStrategyIndex(stats.strategy_name);
    ulong strategy_magic = GetStrategyMagicNumber(strategy_enum);
    
    for(int i = 0; i < deals; i++) {
        ulong deal_ticket = HistoryDealGetTicket(i);
        if(deal_ticket > 0) {
            string deal_comment = HistoryDealGetString(deal_ticket, DEAL_COMMENT);
            double deal_profit = HistoryDealGetDouble(deal_ticket, DEAL_PROFIT);
            ENUM_DEAL_ENTRY deal_entry = (ENUM_DEAL_ENTRY)HistoryDealGetInteger(deal_ticket, DEAL_ENTRY);
            long deal_magic = HistoryDealGetInteger(deal_ticket, DEAL_MAGIC);
            
            if(deal_entry == DEAL_ENTRY_OUT && deal_profit != 0.0) {
                // Check if deal belongs to this strategy by magic number
                if(deal_magic == strategy_magic) {
                    total_trades++;
                    
                    if(deal_profit > 0) {
                        winning_trades++;
                        total_profit += deal_profit;
                    } else {
                        total_loss += MathAbs(deal_profit);
                    }
                }
            }
        }
    }
    
    // Count open positions for this strategy using magic number
    stats.open_positions = 0;
    for(int i = 0; i < PositionsTotal(); i++) {
        ulong ticket = PositionGetTicket(i);
        if(ticket > 0 && PositionSelectByTicket(ticket)) {
            if(PositionGetInteger(POSITION_MAGIC) == strategy_magic) {
                stats.open_positions++;
            }
        }
    }
    
    // Update statistics
    stats.total_trades = total_trades;
    stats.winning_trades = winning_trades;
    stats.total_profit = total_profit - total_loss;
    stats.win_rate = (total_trades > 0) ? (double)winning_trades / total_trades : 0.0;
    stats.avg_profit = (total_trades > 0) ? stats.total_profit / total_trades : 0.0;
    stats.profit_factor = (total_loss > 0) ? total_profit / total_loss : 0.0;
}

//+------------------------------------------------------------------+
//| Get Strategy Index from String                                   |
//+------------------------------------------------------------------+
ENUM_STRATEGY GetStrategyIndex(string strategy_name)
{
    if(StringCompare(strategy_name, "Scalping") == 0) return STRATEGY_SCALPING;
    if(StringCompare(strategy_name, "Swing") == 0) return STRATEGY_SWING;
    if(StringCompare(strategy_name, "Breakout") == 0) return STRATEGY_BREAKOUT;
    if(StringCompare(strategy_name, "MeanRev") == 0) return STRATEGY_MEANREV;
    return STRATEGY_SCALPING; // Default
}
//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
    // Xóa các đối tượng dashboard khi EA bị gỡ bỏ
    ObjectsDeleteAll(0, OBJ_BUTTON, 0, 0);
}
//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
    // Perform analysis once a day
    if(TimeCurrent() - last_analysis_time > 24 * 3600)
    {
        // Reload performance data
        LoadHistoricalPerformance();
        
        // Step 1: Analyze Historical Data
        scalping_score = AnalyzeScalping();
        swing_score = AnalyzeSwingTrading();
        breakout_score = AnalyzeBreakout();
        mean_reversion_score = AnalyzeMeanReversion();
        
        // Step 2: Select Best Strategy
        double scores[] = {scalping_score, swing_score, breakout_score, mean_reversion_score};
        int best_strategy_index = ArrayMaximum(scores, 0, ArraySize(scores));
        
        // Step 3: Execute Selected Strategy
        switch(best_strategy_index)
        {
            case 0: ExecuteScalping(); break;
            case 1: ExecuteSwingTrading(); break;
            case 2: ExecuteBreakout(); break;
            case 3: ExecuteMeanReversion(); break;
            default: Print("No valid strategy selected."); break;
        }
        
        // Step 4: Update Dashboard
        UpdateDashboard();
        
        last_analysis_time = TimeCurrent();
    }
    
    // Update dashboard every minute for real-time performance display
    static datetime last_dashboard_update = 0;
    if(TimeCurrent() - last_dashboard_update > 60) // Update every minute
    {
        // Reload performance data for real-time updates
        LoadHistoricalPerformance();
        UpdateDashboard();
        last_dashboard_update = TimeCurrent();
    }
}

//+------------------------------------------------------------------+
//| Create Dashboard                                                 |
//+------------------------------------------------------------------+
void CreateDashboard()
{
    // Main Dashboard Title (Header) - Increased width by 30% (364 -> 473)
    CreateButton("DashboardTitle", "GPTv2 Dashboard", 10, 220, 473, 25, clrDarkBlue, clrWhite, 12, true);
    
    // Market Information Section - Increased width by 30%
    CreateButton("MarketSectionTitle", "Market Conditions", 10, 195, 473, 20, clrDarkCyan, clrWhite, 10, false);
    CreateButton("ATRLabel", "ATR: N/A", 10, 175, 152, 18, clrDarkGray, clrWhite, 9, false);
    CreateButton("VolatilityLabel", "Vol: N/A", 167, 175, 152, 18, clrDarkGray, clrWhite, 9, false);
    CreateButton("TrendStrengthLabel", "Trend: N/A", 324, 175, 159, 18, clrDarkGray, clrWhite, 9, false);
    
    // Position Information Section - Increased width by 30%
    CreateButton("PositionSectionTitle", "Positions", 10, 155, 473, 18, clrDarkCyan, clrWhite, 10, false);
    CreateButton("TotalPositionsLabel", "Total: N/A", 10, 137, 227, 16, clrDarkGray, clrWhite, 9, false);
    CreateButton("NewsFilterLabel", "News: N/A", 242, 137, 241, 16, clrDarkGray, clrWhite, 9, false);
    
    // Strategy Performance Section - Table Headers - Increased width by 30%
    CreateButton("StrategySectionTitle", "Strategy Performance", 10, 119, 473, 18, clrDarkCyan, clrWhite, 10, false);
    
    // Table headers with different colors - Increased width by 30%
    CreateButton("TableHeader1", "Strategy", 10, 101, 67, 16, clrDarkOrange, clrWhite, 8, false);
    CreateButton("TableHeader2", "Score", 82, 101, 58, 16, clrDarkOrange, clrWhite, 8, false);
    CreateButton("TableHeader3", "Status", 145, 101, 67, 16, clrDarkOrange, clrWhite, 8, false);
    CreateButton("TableHeader4", "Trades", 217, 101, 58, 16, clrDarkOrange, clrWhite, 8, false);
    CreateButton("TableHeader5", "Win%", 280, 101, 50, 16, clrDarkOrange, clrWhite, 8, false);
    CreateButton("TableHeader6", "Profit", 335, 101, 67, 16, clrDarkOrange, clrWhite, 8, false);
    CreateButton("TableHeader7", "Pos", 407, 101, 50, 16, clrDarkOrange, clrWhite, 8, false);
    
    // Scalping Strategy Row - Increased width by 30%
    CreateButton("ScalpingRow", "Scalping", 10, 85, 67, 14, clrDarkSlateGray, clrWhite, 8, false);
    CreateButton("ScalpingScore", "N/A", 82, 85, 58, 14, clrDarkSlateGray, clrWhite, 8, false);
    CreateButton("ScalpingStatus", "N/A", 145, 85, 67, 14, clrDarkSlateGray, clrWhite, 8, false);
    CreateButton("ScalpingTrades", "N/A", 217, 85, 58, 14, clrDarkSlateGray, clrWhite, 8, false);
    CreateButton("ScalpingWinRate", "N/A", 280, 85, 50, 14, clrDarkSlateGray, clrWhite, 8, false);
    CreateButton("ScalpingProfit", "N/A", 335, 85, 67, 14, clrDarkSlateGray, clrWhite, 8, false);
    CreateButton("ScalpingPositions", "N/A", 407, 85, 50, 14, clrDarkSlateGray, clrWhite, 8, false);
    
    // Swing Trading Strategy Row - Increased width by 30%
    CreateButton("SwingRow", "Swing", 10, 71, 67, 14, clrDarkSlateGray, clrWhite, 8, false);
    CreateButton("SwingScore", "N/A", 82, 71, 58, 14, clrDarkSlateGray, clrWhite, 8, false);
    CreateButton("SwingStatus", "N/A", 145, 71, 67, 14, clrDarkSlateGray, clrWhite, 8, false);
    CreateButton("SwingTrades", "N/A", 217, 71, 58, 14, clrDarkSlateGray, clrWhite, 8, false);
    CreateButton("SwingWinRate", "N/A", 280, 71, 50, 14, clrDarkSlateGray, clrWhite, 8, false);
    CreateButton("SwingProfit", "N/A", 335, 71, 67, 14, clrDarkSlateGray, clrWhite, 8, false);
    CreateButton("SwingPositions", "N/A", 407, 71, 50, 14, clrDarkSlateGray, clrWhite, 8, false);
    
    // Breakout Strategy Row - Increased width by 30%
    CreateButton("BreakoutRow", "Breakout", 10, 57, 67, 14, clrDarkSlateGray, clrWhite, 8, false);
    CreateButton("BreakoutScore", "N/A", 82, 57, 58, 14, clrDarkSlateGray, clrWhite, 8, false);
    CreateButton("BreakoutStatus", "N/A", 145, 57, 67, 14, clrDarkSlateGray, clrWhite, 8, false);
    CreateButton("BreakoutTrades", "N/A", 217, 57, 58, 14, clrDarkSlateGray, clrWhite, 8, false);
    CreateButton("BreakoutWinRate", "N/A", 280, 57, 50, 14, clrDarkSlateGray, clrWhite, 8, false);
    CreateButton("BreakoutProfit", "N/A", 335, 57, 67, 14, clrDarkSlateGray, clrWhite, 8, false);
    CreateButton("BreakoutPositions", "N/A", 407, 57, 50, 14, clrDarkSlateGray, clrWhite, 8, false);
    
    // Mean Reversion Strategy Row - Increased width by 30%
    CreateButton("MeanRevRow", "MeanRev", 10, 43, 67, 14, clrDarkSlateGray, clrWhite, 8, false);
    CreateButton("MeanRevScore", "N/A", 82, 43, 58, 14, clrDarkSlateGray, clrWhite, 8, false);
    CreateButton("MeanRevStatus", "N/A", 145, 43, 67, 14, clrDarkSlateGray, clrWhite, 8, false);
    CreateButton("MeanRevTrades", "N/A", 217, 43, 58, 14, clrDarkSlateGray, clrWhite, 8, false);
    CreateButton("MeanRevWinRate", "N/A", 280, 43, 50, 14, clrDarkSlateGray, clrWhite, 8, false);
    CreateButton("MeanRevProfit", "N/A", 335, 43, 67, 14, clrDarkSlateGray, clrWhite, 8, false);
    CreateButton("MeanRevPositions", "N/A", 407, 43, 50, 14, clrDarkSlateGray, clrWhite, 8, false);
    
    // Overall Performance Summary - Increased width by 30%
    CreateButton("SummarySectionTitle", "Overall Performance", 10, 27, 473, 16, clrDarkCyan, clrWhite, 10, false);
    CreateButton("ActiveStrategiesLabel", "Active: N/A", 10, 11, 152, 14, clrDarkGray, clrWhite, 8, false);
    CreateButton("OverallWinRateLabel", "Win%: N/A", 167, 11, 152, 14, clrDarkGray, clrWhite, 8, false);
    CreateButton("OverallProfitFactorLabel", "PF: N/A", 324, 11, 159, 14, clrDarkGray, clrWhite, 8, false);
    
    // Strategy Configuration Table - New section on the right
    CreateButton("ConfigSectionTitle", "Strategy Configuration", 500, 220, 300, 25, clrDarkBlue, clrWhite, 12, true);
    
    // Configuration Table Headers
    CreateButton("ConfigHeader1", "Strategy", 500, 195, 80, 20, clrDarkOrange, clrWhite, 9, false);
    CreateButton("ConfigHeader2", "Parameters", 580, 195, 220, 20, clrDarkOrange, clrWhite, 9, false);
    
    // Scalping Configuration Row
    CreateButton("ScalpingConfigRow", "Scalping", 500, 175, 80, 18, clrDarkSlateGray, clrWhite, 8, false);
    CreateButton("ScalpingConfigParams", "BB(20,2) | ATR(14) | SL:1.0x | TP:2.0x", 580, 175, 220, 18, clrDarkSlateGray, clrWhite, 7, false);
    
    // Swing Configuration Row
    CreateButton("SwingConfigRow", "Swing", 500, 157, 80, 18, clrDarkSlateGray, clrWhite, 8, false);
    CreateButton("SwingConfigParams", "RSI(14) | MA(9,21) | SL:1.5x | TP:3.0x", 580, 157, 220, 18, clrDarkSlateGray, clrWhite, 7, false);
    
    // Breakout Configuration Row
    CreateButton("BreakoutConfigRow", "Breakout", 500, 139, 80, 18, clrDarkSlateGray, clrWhite, 8, false);
    CreateButton("BreakoutConfigParams", "Pivot(D1) | Vol(1.2x) | SL:1.0x | TP:2.0x", 580, 139, 220, 18, clrDarkSlateGray, clrWhite, 7, false);
    
    // Mean Reversion Configuration Row
    CreateButton("MeanRevConfigRow", "MeanRev", 500, 121, 80, 18, clrDarkSlateGray, clrWhite, 8, false);
    CreateButton("MeanRevConfigParams", "BB(20,2.0) | ATR(14) | SL:1.0x | TP:2.0x", 580, 121, 220, 18, clrDarkSlateGray, clrWhite, 7, false);
    
    // Market Conditions Configuration
    CreateButton("MarketConfigTitle", "Market Conditions", 500, 103, 300, 18, clrDarkCyan, clrWhite, 10, false);
    CreateButton("MarketConfigParams", "Trend(20) | Vol(14) | News(30min) | Lot:0.01", 500, 85, 300, 16, clrDarkGray, clrWhite, 8, false);
    
    // Risk Management Configuration
    CreateButton("RiskConfigTitle", "Risk Management", 500, 67, 300, 18, clrDarkCyan, clrWhite, 10, false);
    CreateButton("RiskConfigParams", "Risk:0.05% | MaxPos:1 | Trailing:1.5x | Partial:50%", 500, 49, 300, 16, clrDarkGray, clrWhite, 8, false);
    
    // Timeframe Configuration
    CreateButton("TimeframeConfigTitle", "Timeframe Settings", 500, 31, 300, 18, clrDarkCyan, clrWhite, 10, false);
    CreateButton("TimeframeConfigParams", "Main:H1 | Pivot:H4/D1 | Analysis:7 days", 500, 13, 300, 16, clrDarkGray, clrWhite, 8, false);
    
    ChartRedraw();
}

//+------------------------------------------------------------------+
//| Create Button Helper Function                                   |
//+------------------------------------------------------------------+
void CreateButton(string name, string text, int x, int y, int width, int height, color bg_color, color text_color, int font_size, bool is_selectable = false)
{
    if(ObjectFind(0, name) >= 0) return;
    
    if(!ObjectCreate(0, name, OBJ_BUTTON, 0, 0, 0)) return;
    
    ObjectSetString(0, name, OBJPROP_TEXT, text);
    ObjectSetInteger(0, name, OBJPROP_XDISTANCE, x);
    ObjectSetInteger(0, name, OBJPROP_YDISTANCE, y);
    ObjectSetInteger(0, name, OBJPROP_XSIZE, width);
    ObjectSetInteger(0, name, OBJPROP_YSIZE, height);
    ObjectSetInteger(0, name, OBJPROP_CORNER, CORNER_LEFT_LOWER);
    ObjectSetInteger(0, name, OBJPROP_FONTSIZE, font_size);
    ObjectSetInteger(0, name, OBJPROP_COLOR, text_color);
    ObjectSetInteger(0, name, OBJPROP_BGCOLOR, bg_color);
    ObjectSetInteger(0, name, OBJPROP_BORDER_COLOR, clrBlack);
    ObjectSetInteger(0, name, OBJPROP_BORDER_TYPE, BORDER_FLAT);
    ObjectSetInteger(0, name, OBJPROP_STATE, false);
    ObjectSetInteger(0, name, OBJPROP_SELECTABLE, is_selectable);
}

//+------------------------------------------------------------------+
//| Update Button Helper Function                                   |
//+------------------------------------------------------------------+
void UpdateButton(string name, string text, color text_color = clrWhite, color bg_color = clrDarkGray)
{
    if(ObjectFind(0, name) >= 0) {
        ObjectSetString(0, name, OBJPROP_TEXT, text);
        ObjectSetInteger(0, name, OBJPROP_COLOR, text_color);
        ObjectSetInteger(0, name, OBJPROP_BGCOLOR, bg_color);
    }
}

//+------------------------------------------------------------------+
//| Update Dashboard                                                 |
//+------------------------------------------------------------------+
void UpdateDashboard()
{
    // Reload performance data
    LoadHistoricalPerformance();
    
    // Update market information
    current_atr = GetCurrentATR();
    UpdateButton("ATRLabel", StringFormat("ATR: %.4f", current_atr));
    
    // Update volatility (placeholder for now)
    double volatility = 0.0;
    UpdateButton("VolatilityLabel", StringFormat("Vol: %.4f", volatility));
    
    // Update trend strength (placeholder for now)
    string trend_status = "Sideways";
    color trend_bg_color = clrDarkGray;
    UpdateButton("TrendStrengthLabel", StringFormat("Trend: %s", trend_status), clrWhite, trend_bg_color);
    
    // Update position information
    int total_positions = 0;
    for(int i = 0; i < 4; i++) {
        total_positions += strategy_stats[i].open_positions;
    }
    UpdateButton("TotalPositionsLabel", StringFormat("Total: %d", total_positions));
    
    // Update news filter status (placeholder for now)
    string news_status = "Inactive";
    color news_bg_color = clrDarkGreen;
    UpdateButton("NewsFilterLabel", StringFormat("News: %s", news_status), clrWhite, news_bg_color);
    
    // Update strategy performance table with real data
    UpdateStrategyPerformanceTable("Scalping", 0, scalping_score);
    UpdateStrategyPerformanceTable("Swing", 1, swing_score);
    UpdateStrategyPerformanceTable("Breakout", 2, breakout_score);
    UpdateStrategyPerformanceTable("MeanRev", 3, mean_reversion_score);
    
    // Update overall performance summary
    UpdateOverallPerformanceTable();
    
    // Update configuration table
    UpdateConfigurationTable();
    
    ChartRedraw();
}

//+------------------------------------------------------------------+
//| Update Strategy Performance Table                                |
//+------------------------------------------------------------------+
void UpdateStrategyPerformanceTable(string strategy_prefix, int strategy_index, double score)
{
    StrategyPerformance stats = strategy_stats[strategy_index];
    
    // Update score
    UpdateButton(strategy_prefix + "Score", StringFormat("%.2f", score));
    
    // Update status based on score
    string status = (score > 0.5) ? "ACTIVE" : "Inactive";
    color status_bg_color = (score > 0.5) ? clrDarkGreen : clrDarkGray;
    UpdateButton(strategy_prefix + "Status", status, clrWhite, status_bg_color);
    
    // Update trades count
    UpdateButton(strategy_prefix + "Trades", IntegerToString(stats.total_trades));
    
    // Update win rate with color coding
    color win_rate_bg_color = clrDarkGray;
    if(stats.win_rate > 0.6) win_rate_bg_color = clrDarkGreen;
    else if(stats.win_rate < 0.4) win_rate_bg_color = clrDarkRed;
    
    string win_rate_text = "0%";
    if(stats.total_trades > 0) {
        win_rate_text = StringFormat("%.0f%%", stats.win_rate * 100);
    }
    UpdateButton(strategy_prefix + "WinRate", win_rate_text, clrWhite, win_rate_bg_color);
    
    // Update profit with color coding
    color profit_bg_color = (stats.total_profit > 0) ? clrDarkGreen : clrDarkRed;
    string profit_text = "0.00";
    if(stats.total_trades > 0) {
        profit_text = StringFormat("%.2f", stats.total_profit);
    }
    UpdateButton(strategy_prefix + "Profit", profit_text, clrWhite, profit_bg_color);
    
    // Update positions count with proper counting
    int open_positions_count = CountOpenPositionsForStrategy(strategy_index);
    string position_status = (open_positions_count > 0) ? IntegerToString(open_positions_count) : "0";
    color position_bg_color = (open_positions_count > 0) ? clrDarkOrange : clrDarkGray;
    UpdateButton(strategy_prefix + "Positions", position_status, clrWhite, position_bg_color);
}

//+------------------------------------------------------------------+
//| Count Open Positions for Specific Strategy                       |
//+------------------------------------------------------------------+
int CountOpenPositionsForStrategy(int strategy_index)
{
    int count = 0;
    string strategy_names[] = {"Scalping", "Swing", "Breakout", "MeanRev"};
    string target_strategy = strategy_names[strategy_index];
    
    ENUM_STRATEGY strategy_enum = GetStrategyIndex(target_strategy);
    ulong strategy_magic = GetStrategyMagicNumber(strategy_enum);
    
    for(int i = 0; i < PositionsTotal(); i++) {
        ulong ticket = PositionGetTicket(i);
        if(ticket > 0 && PositionSelectByTicket(ticket)) {
            if(PositionGetInteger(POSITION_MAGIC) == strategy_magic) {
                count++;
            }
        }
    }
    
    return count;
}

//+------------------------------------------------------------------+
//| Update Overall Performance Table                                 |
//+------------------------------------------------------------------+
void UpdateOverallPerformanceTable()
{
    // Update active strategies count based on scores
    int active_strategies = 0;
    if(scalping_score > 0.5) active_strategies++;
    if(swing_score > 0.5) active_strategies++;
    if(breakout_score > 0.5) active_strategies++;
    if(mean_reversion_score > 0.5) active_strategies++;
    
    UpdateButton("ActiveStrategiesLabel", StringFormat("Active: %d", active_strategies));
    
    // Calculate overall win rate
    double overall_win_rate = CalculateOverallWinRate();
    color win_rate_bg_color = clrDarkGray;
    if(overall_win_rate > 0.6) win_rate_bg_color = clrDarkGreen;
    else if(overall_win_rate < 0.4) win_rate_bg_color = clrDarkRed;
    
    string overall_win_rate_text = "Win%: 0%";
    if(overall_win_rate > 0) {
        overall_win_rate_text = StringFormat("Win%%: %.0f%%", overall_win_rate * 100);
    }
    UpdateButton("OverallWinRateLabel", overall_win_rate_text, clrWhite, win_rate_bg_color);
    
    // Calculate overall profit factor
    double overall_profit_factor = CalculateOverallProfitFactor();
    color profit_factor_bg_color = clrDarkGray;
    if(overall_profit_factor > 1.5) profit_factor_bg_color = clrDarkGreen;
    else if(overall_profit_factor < 1.0) profit_factor_bg_color = clrDarkRed;
    
    string overall_pf_text = "PF: 0.00";
    if(overall_profit_factor > 0) {
        overall_pf_text = StringFormat("PF: %.2f", overall_profit_factor);
    }
    UpdateButton("OverallProfitFactorLabel", overall_pf_text, clrWhite, profit_factor_bg_color);
}

//+------------------------------------------------------------------+
//| Calculate Overall Win Rate                                       |
//+------------------------------------------------------------------+
double CalculateOverallWinRate()
{
    int total_trades = 0;
    int total_wins = 0;
    
    for(int i = 0; i < 4; i++) {
        total_trades += strategy_stats[i].total_trades;
        total_wins += strategy_stats[i].winning_trades;
    }
    
    return (total_trades > 0) ? (double)total_wins / total_trades : 0.0;
}

//+------------------------------------------------------------------+
//| Calculate Overall Profit Factor                                  |
//+------------------------------------------------------------------+
double CalculateOverallProfitFactor()
{
    double total_profit = 0.0;
    double total_loss = 0.0;
    
    for(int i = 0; i < 4; i++) {
        if(strategy_stats[i].total_profit > 0) {
            total_profit += strategy_stats[i].total_profit;
        } else {
            total_loss += MathAbs(strategy_stats[i].total_profit);
        }
    }
    
    return (total_loss > 0) ? total_profit / total_loss : 0.0;
}

//+------------------------------------------------------------------+
//| Update Configuration Table                                       |
//+------------------------------------------------------------------+
void UpdateConfigurationTable()
{
    // This function updates the configuration display
    // The configuration is static for now, but could be made dynamic
    // based on actual parameter values
}

//+------------------------------------------------------------------+
//| Get Current ATR                                                  |
//+------------------------------------------------------------------+
double GetCurrentATR()
{
    // Tạo handle cho chỉ báo ATR với chu kỳ 14
    int atr_handle = iATR(_Symbol, Timeframe, 14);
    if(atr_handle == INVALID_HANDLE)
    {
        Print("Error creating ATR handle: ", GetLastError());
        return 0.0;
    }

    double atr[];
    // Lấy giá trị ATR gần nhất
    if(CopyBuffer(atr_handle, 0, 0, 1, atr) <= 0)
    {
        Print("Error copying ATR data: ", GetLastError());
        IndicatorRelease(atr_handle);
        return 0.0;
    }

    IndicatorRelease(atr_handle);
    return atr[0];
}



//+------------------------------------------------------------------+
//| Strategy Performance Evaluation Functions                       |
//+------------------------------------------------------------------+
double AnalyzeScalping()
{
    // Use real performance data from strategy_stats
    StrategyPerformance stats = strategy_stats[0]; // Scalping is index 0
    
    double drawdown = (stats.max_drawdown > 0) ? stats.max_drawdown / 100.0 : 0.1; // Convert to percentage
    double win_rate = stats.win_rate;
    double avg_profit = (stats.avg_profit > 0) ? stats.avg_profit / 100.0 : 0.002; // Convert to percentage
    
    double score = (1 - drawdown) * MaxDrawdownWeight + win_rate * WinRateWeight + avg_profit * AvgProfitWeight;
    return score;
}

double AnalyzeSwingTrading()
{
    // Use real performance data from strategy_stats
    StrategyPerformance stats = strategy_stats[1]; // Swing is index 1
    
    double drawdown = (stats.max_drawdown > 0) ? stats.max_drawdown / 100.0 : 0.1;
    double win_rate = stats.win_rate;
    double avg_profit = (stats.avg_profit > 0) ? stats.avg_profit / 100.0 : 0.002;
    
    double score = (1 - drawdown) * MaxDrawdownWeight + win_rate * WinRateWeight + avg_profit * AvgProfitWeight;
    return score;
}

double AnalyzeBreakout()
{
    // Use real performance data from strategy_stats
    StrategyPerformance stats = strategy_stats[2]; // Breakout is index 2
    
    double drawdown = (stats.max_drawdown > 0) ? stats.max_drawdown / 100.0 : 0.1;
    double win_rate = stats.win_rate;
    double avg_profit = (stats.avg_profit > 0) ? stats.avg_profit / 100.0 : 0.002;
    
    double score = (1 - drawdown) * MaxDrawdownWeight + win_rate * WinRateWeight + avg_profit * AvgProfitWeight;
    return score;
}

double AnalyzeMeanReversion()
{
    // Use real performance data from strategy_stats
    StrategyPerformance stats = strategy_stats[3]; // MeanReversion is index 3
    
    double drawdown = (stats.max_drawdown > 0) ? stats.max_drawdown / 100.0 : 0.1;
    double win_rate = stats.win_rate;
    double avg_profit = (stats.avg_profit > 0) ? stats.avg_profit / 100.0 : 0.002;
    
    double score = (1 - drawdown) * MaxDrawdownWeight + win_rate * WinRateWeight + avg_profit * AvgProfitWeight;
    return score;
}



//+------------------------------------------------------------------+
//| Strategy Execution Functions                                    |
//+------------------------------------------------------------------+
void ExecuteScalping()
{
    // Implement Scalping strategy execution
    Print("Executing Scalping Strategy...");
    // Calculate Bollinger Bands
    int bb_handle = iBands(_Symbol, Timeframe, ScalpingBollingerBandsPeriod, 2, 0, PRICE_CLOSE);
    if(bb_handle == INVALID_HANDLE)
    {
        Print("Error creating Bollinger Bands handle: ", GetLastError());
        return;
    }
    
    double upper[], lower[];
    // CopyBuffer indices: 0 - Upper Band, 1 - Middle Band, 2 - Lower Band
    if(CopyBuffer(bb_handle, 0, 0, 1, upper) <= 0 || CopyBuffer(bb_handle, 2, 0, 1, lower) <= 0)
    {
        Print("Error copying Bollinger Bands data: ", GetLastError());
        IndicatorRelease(bb_handle);
        return;
    }
    
    double current_price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    
    // Example Buy Signal
    if(current_price < lower[0])
    {
        OpenBuyOrder("Scalping");
    }
    
    // Example Sell Signal
    if(current_price > upper[0])
    {
        OpenSellOrder("Scalping");
    }
    
    // Release indicator handle
    IndicatorRelease(bb_handle);
}

void ExecuteSwingTrading()
{
    // Implement Swing Trading strategy execution
    Print("Executing Swing Trading Strategy...");
    // RSI
    int rsi_handle = iRSI(_Symbol, Timeframe, RSIPeriod, PRICE_CLOSE);
    // handle_iRSI=iRSI(m_symbol.Name(),Period(),rsi_ma_period,PRICE_CLOSE);
    if(rsi_handle == INVALID_HANDLE)
    {
        Print("Error creating RSI handle: ", GetLastError());
        return;
    }
    
    double rsi[];
    if(CopyBuffer(rsi_handle, 0, 0, 1, rsi) <= 0)
    {
        Print("Error copying RSI data: ", GetLastError());
        IndicatorRelease(rsi_handle);
        return;
    }
    
    // Fast MA
    int ma_fast_handle = iMA(_Symbol, Timeframe, FastMAPeriod, 0, MODE_SMA, PRICE_CLOSE);
    if(ma_fast_handle == INVALID_HANDLE)
    {
        Print("Error creating Fast MA handle: ", GetLastError());
        IndicatorRelease(rsi_handle);
        return;
    }
    
    double ma_fast[];
    if(CopyBuffer(ma_fast_handle, 0, 0, 1, ma_fast) <= 0)
    {
        Print("Error copying Fast MA data: ", GetLastError());
        IndicatorRelease(rsi_handle);
        IndicatorRelease(ma_fast_handle);
        return;
    }
    
    // Slow MA
    int ma_slow_handle = iMA(_Symbol, Timeframe, SlowMAPeriod, 0, MODE_SMA, PRICE_CLOSE);
    if(ma_slow_handle == INVALID_HANDLE)
    {
        Print("Error creating Slow MA handle: ", GetLastError());
        IndicatorRelease(rsi_handle);
        IndicatorRelease(ma_fast_handle);
        return;
    }
    
    double ma_slow[];
    if(CopyBuffer(ma_slow_handle, 0, 0, 1, ma_slow) <= 0)
    {
        Print("Error copying Slow MA data: ", GetLastError());
        IndicatorRelease(rsi_handle);
        IndicatorRelease(ma_fast_handle);
        IndicatorRelease(ma_slow_handle);
        return;
    }
    
    double current_price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    
    // Buy Condition
    if(rsi[0] < 30 && current_price < ma_fast[0] && current_price > ma_slow[0])
    {
        OpenBuyOrder("Swing");
    }
    
    // Sell Condition
    if(rsi[0] > 70 && current_price > ma_fast[0] && current_price < ma_slow[0])
    {
        OpenSellOrder("Swing");
    }
    
    // Release indicator handles
    IndicatorRelease(rsi_handle);
    IndicatorRelease(ma_fast_handle);
    IndicatorRelease(ma_slow_handle);
}

void ExecuteBreakout()
{
    // Implement Breakout strategy execution
    Print("Executing Breakout Strategy...");
    // Calculate Pivot Point
    double pivot = CalculatePivotPoint(_Symbol, PivotPointPeriodTF);
    double resistance = pivot + 0.0010; // Example offset, cần điều chỉnh theo tài sản
    double support = pivot - 0.0010; // Example offset, cần điều chỉnh theo tài sản
    double current_price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    
    // Example Buy Signal
    if(current_price > resistance)
    {
        OpenBuyOrder("Breakout");
    }
    
    // Example Sell Signal
    if(current_price < support)
    {
        OpenSellOrder("Breakout");
    }
}

void ExecuteMeanReversion()
{
    // Implement Mean Reversion strategy execution
    Print("Executing Mean Reversion Strategy...");
    // Calculate Bollinger Bands
    int bb_handle = iBands(_Symbol, Timeframe, ScalpingBollingerBandsPeriod, MeanReversionBollingerBandsDeviation, 0, PRICE_CLOSE);
    if(bb_handle == INVALID_HANDLE)
    {
        Print("Error creating Bollinger Bands handle: ", GetLastError());
        return;
    }
    
    double upper[], lower[], middle[];
    // CopyBuffer indices: 0 - Upper Band, 1 - Middle Band, 2 - Lower Band
    if(CopyBuffer(bb_handle, 0, 0, 1, upper) <= 0 ||
       CopyBuffer(bb_handle, 1, 0, 1, middle) <= 0 ||
       CopyBuffer(bb_handle, 2, 0, 1, lower) <= 0)
    {
        Print("Error copying Bollinger Bands data: ", GetLastError());
        IndicatorRelease(bb_handle);
        return;
    }
    
    double current_price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    
    // Buy Signal
    if(current_price < lower[0])
    {
        OpenBuyOrder("MeanRev");
    }
    
    // Sell Signal
    if(current_price > upper[0])
    {
        OpenSellOrder("MeanRev");
    }
    
    // Release indicator handle
    IndicatorRelease(bb_handle);
}

//+------------------------------------------------------------------+
//| Order Execution Functions                                       |
//+------------------------------------------------------------------+
void OpenBuyOrder(string strategy)
{
    double lot_size = CalculateLotSize(strategy);
    double price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
    double sl = price - CalculateStopLoss(strategy);
    double tp = price + CalculateTakeProfit(strategy);
    
    MqlTradeRequest request;
    MqlTradeResult result;
    ZeroMemory(request);
    ZeroMemory(result);
    
    request.action = TRADE_ACTION_DEAL;
    request.symbol = _Symbol;
    request.volume = lot_size;
    request.type = ORDER_TYPE_BUY;
    request.price = price;
    request.sl = sl;
    request.tp = tp;
    request.deviation = 10;
    request.magic = GetStrategyMagicNumber(GetStrategyIndex(strategy));
    request.comment = "Buy Order - " + strategy;
    
    if(!OrderSend(request, result))
    {
        Print("Error opening Buy Order: ", result.comment);
    }
    else
    {
        Print("Buy Order opened successfully. Ticket: ", result.order);
    }
}

void OpenSellOrder(string strategy)
{
    double lot_size = CalculateLotSize(strategy);
    double price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double sl = price + CalculateStopLoss(strategy);
    double tp = price - CalculateTakeProfit(strategy);
    
    MqlTradeRequest request;
    MqlTradeResult result;
    ZeroMemory(request);
    ZeroMemory(result);
    
    request.action = TRADE_ACTION_DEAL;
    request.symbol = _Symbol;
    request.volume = lot_size;
    request.type = ORDER_TYPE_SELL;
    request.price = price;
    request.sl = sl;
    request.tp = tp;
    request.deviation = 10;
    request.magic = GetStrategyMagicNumber(GetStrategyIndex(strategy));
    request.comment = "Sell Order - " + strategy;
    
    if(!OrderSend(request, result))
    {
        Print("Error opening Sell Order: ", result.comment);
    }
    else
    {
        Print("Sell Order opened successfully. Ticket: ", result.order);
    }
}

//+------------------------------------------------------------------+
//| Risk and Lot Size Calculation Functions                        |
//+------------------------------------------------------------------+
double CalculateLotSize(string strategy)
{
    if(StringCompare(RiskManagementMode, "FixedLot") == 0)
    {
        return FixedLotSize;
    }
    else if(StringCompare(RiskManagementMode, "Risk-Based") == 0)
    {
        // Implement risk-based lot size calculation
        double account_balance = AccountInfoDouble(ACCOUNT_BALANCE);
        double risk_amount = account_balance * (RiskPercentage / 100.0);
        double sl = CalculateStopLoss(strategy);
        double tick_value;
        if(!SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE, tick_value))
        {
            Print("Error getting tick value: ", GetLastError());
            return FixedLotSize; // Fallback
        }
        double lot_size = risk_amount / (sl / _Point * tick_value);
        lot_size = NormalizeDouble(lot_size, 2); // Adjust decimal places as needed
        return lot_size;
    }
    else
    {
        // Default to fixed lot size
        return FixedLotSize;
    }
}

double CalculateStopLoss(string strategy)
{
    // Tạo handle cho chỉ báo ATR với chu kỳ 14
    int atr_handle = iATR(_Symbol, Timeframe, 14);
    if(atr_handle == INVALID_HANDLE)
    {
        Print("Error creating ATR handle: ", GetLastError());
        return 50 * _Point; // Fallback
    }

    double atr[];
    // Lấy giá trị ATR gần nhất
    if(CopyBuffer(atr_handle, 0, 0, 1, atr) <= 0)
    {
        Print("Error copying ATR data: ", GetLastError());
        IndicatorRelease(atr_handle);
        return 50 * _Point; // Fallback
    }

    IndicatorRelease(atr_handle);

    // Xác định hệ số ATR multiplier dựa trên chiến lược
    double sl_atr_multiplier = 1.0; // Default
    if(StringCompare(strategy, "Scalping") == 0)
    {
        sl_atr_multiplier = ScalpingSL_ATR_Multiplier;
    }
    else if(StringCompare(strategy, "Swing") == 0)
    {
        sl_atr_multiplier = SwingSL_ATR_Multiplier;
    }
    else if(StringCompare(strategy, "Breakout") == 0)
    {
        sl_atr_multiplier = BreakoutSL_ATR_Multiplier;
    }
    else if(StringCompare(strategy, "MeanRev") == 0)
    {
        sl_atr_multiplier = MeanReversionSL_ATR_Multiplier;
    }

    double sl = atr[0] * sl_atr_multiplier;
    return sl;
}

double CalculateTakeProfit(string strategy)
{
    // Tạo handle cho chỉ báo ATR với chu kỳ 14
    int atr_handle = iATR(_Symbol, Timeframe, 14);
    if(atr_handle == INVALID_HANDLE)
    {
        Print("Error creating ATR handle: ", GetLastError());
        return 100 * _Point; // Fallback
    }

    double atr[];
    // Lấy giá trị ATR gần nhất
    if(CopyBuffer(atr_handle, 0, 0, 1, atr) <= 0)
    {
        Print("Error copying ATR data: ", GetLastError());
        IndicatorRelease(atr_handle);
        return 100 * _Point; // Fallback
    }

    IndicatorRelease(atr_handle);

    // Xác định hệ số ATR multiplier dựa trên chiến lược
    double tp_atr_multiplier = 2.0; // Default
    if(StringCompare(strategy, "Scalping") == 0)
    {
        tp_atr_multiplier = ScalpingTP_ATR_Multiplier;
    }
    else if(StringCompare(strategy, "Swing") == 0)
    {
        tp_atr_multiplier = SwingTP_ATR_Multiplier;
    }
    else if(StringCompare(strategy, "Breakout") == 0)
    {
        tp_atr_multiplier = BreakoutTP_ATR_Multiplier;
    }
    else if(StringCompare(strategy, "MeanRev") == 0)
    {
        tp_atr_multiplier = MeanReversionTP_ATR_Multiplier;
    }

    double tp = atr[0] * tp_atr_multiplier;
    return tp;
}

//+------------------------------------------------------------------+
//| Pivot Point Calculation (Simple Example)                        |
//+------------------------------------------------------------------+
double CalculatePivotPoint(string symbol, ENUM_TIMEFRAMES timeframe)
{
    // Tính Pivot Point dựa trên phiên trước
    datetime prev_time = iTime(symbol, timeframe, 1);
    
    double high = iHigh(symbol, timeframe, 1);
    double low = iLow(symbol, timeframe, 1);
    double close = iClose(symbol, timeframe, 1);
    
    double pivot = (high + low + close) / 3.0;
    return pivot;
}

//+------------------------------------------------------------------+
